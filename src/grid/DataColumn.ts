import Inflector from 'inflected';
import ActiveDataProvider from '../data/ActiveDataProvider';
import ArrayDataProvider from '../data/ArrayDataProvider';
import Column from './Column';
import Html from '../helpers/Html';
import DataHelper from '../helpers/DataHelper';
import Model from '../base/Model';
/**
 * DataColumn is the default column type for the [[GridView]] widget.
 *
 * It is used to show data columns and allows [[enableSorting|sorting]] and [[filter|filtering]] them.
 *
 * A simple data column definition refers to an attribute in the data model of the
 * GridView's data provider. The name of the attribute is specified by [[attribute]].
 *
 * By setting [[value]] and [[label]], the header and cell content can be customized.
 *
 * A data column differentiates between the [[getDataCellValue|data cell value]] and the
 * [[renderDataCellContent|data cell content]]. The cell value is an un-formatted value that
 * may be used for calculation, while the actual cell content is a [[format|formatted]] version of that
 * value which may contain HTML markup.
 *
 * For more details and usage information on DataColumn, see the [guide article on data widgets](guide:output-data-widgets).
 *
 */
export default class DataColumn extends Column {
  /**
   * The attribute name associated with this column. When neither [[content]] nor [[value]]
   * is specified, the value of the specified attribute will be retrieved from each data model and displayed.
   *
   * Also, if [[label]] is not specified, the label associated with the attribute will be displayed.
   */
  public attribute;
  /**
   * Label to be displayed in the [[header|header cell]] and also to be used as the sorting
   * link label when sorting is enabled for this column.
   * If it is not set and the models provided by the GridViews data provider are instances
   * of [[ActiveRecord]], the label will be determined using [[ActiveRecord.getAttributeLabel]].
   * Otherwise [[Inflector.camel2words]] will be used to get a label.
   */
  public label;
  /**
   * Whether the header label should be HTML-encoded.
   * @see label
   */
  public encodeLabel = true;
  /**
   * Closure an anonymous function or a string that is used to determine the value to display in the current column.
   *
   * If this is an anonymous function, it will be called for each row and the return value will be used as the value to
   * display for every data model. The signature of this function should be: `function (model, key, index, column)`.
   * Where `model`, `key`, and `index` refer to the model, key and index of the row currently being rendered
   * and `column` is a reference to the [[DataColumn]] object.
   *
   * You may also set this property to a string representing the attribute name to be displayed in this column.
   * This can be used when the attribute to be displayed is different from the [[attribute]] that is used for
   * sorting and filtering.
   *
   * If this is not set, `model[attribute]` will be used to obtain the value, where `attribute` is the value of [[attribute]].
   */
  public value;
  /**
   * Closure in which format should the value of each data model be displayed as (e.g. `"raw"`, `"text"`, `"html"`,
   * `['date', 'js:Y-m-d']`). Supported formats are determined by the [[GridView.formatter|formatter]] used by
   * the [[GridView]]. Default format is "text" which will format the value as an HTML-encoded plain text when
   * [[Formatter]] is used as the [[GridView.formatter|formatter]] of the GridView.
   * @see [[Formatter.format]]
   */
  public format = 'text';
  /**
   * Whether to allow sorting by this column. If true and [[attribute]] is found in
   * the sort definition of [[GridView.dataProvider]], then the header cell of this column
   * will contain a link that may trigger the sorting when being clicked.
   */
  public enableSorting = true;
  /**
   * The HTML attributes for the link tag in the header cell
   * generated by [[Sort.link]] when sorting is enabled for this column.
   * @see [[Html.renderTagAttributes]] for details on how attributes are being rendered.
   */
  public sortLinkOptions: any = {};
  /**
   * The HTML code representing a filter input (e.g. a text field, a dropdown list)
   * that is used for this data column. This property is effective only when [[GridView.filterModel]] is set.
   *
   * - If this property is not set, a text field will be generated as the filter input with attributes defined
   *   with [[filterInputOptions]]. See [[BaseHtml.activeInput]] for details on how an active
   *   input tag is generated.
   * - If this property is an array, a dropdown list will be generated that uses this property value as
   *   the list options.
   * - If you don't want a filter for this data column, set this value to be false.
   */
  public filter;
  /**
   * The HTML attributes for the filter input fields. This property is used in combination with
   * the [[filter]] property. When [[filter]] is not set or is an array, this property will be used to
   * render the HTML attributes for the generated filter input fields.
   *
   * Empty `id` in the default value ensures that id would not be obtained from the model attribute thus
   * providing better performance.
   *
   * @see [[Html.renderTagAttributes]] for details on how attributes are being rendered.
   */
  public filterInputOptions: any = { class: 'form-control', id: null };
  /**
   * The attribute name of the [[GridView.filterModel]] associated with this column. If not set,
   * will have the same value as [[attribute]].
   */
  public filterAttribute;

  public constructor(config: { [key: string]: any }) {
    super(config);
    Object.assign(this, config);
  }
  /** @inheritdoc */
  public async init() {
    await super.init.call(this);
    if (this.filterAttribute === undefined) this.filterAttribute = this.attribute;
  }
  /** @inheritdoc */
  protected async renderHeaderCellContent(): Promise<string> {
    if (this.header !== undefined || (this.label === undefined && this.attribute === undefined))
      return super.renderHeaderCellContent();
    let label = await this.getHeaderCellLabel();

    if (this.encodeLabel) label = Html.encode(label);
    const sort = this.grid.dataProvider.getSort();

    if (this.attribute !== undefined && this.enableSorting && sort !== false && sort.hasAttribute(this.attribute))
      return sort.link(this.attribute, { ...this.sortLinkOptions, label });
    return label;
  }
  /** @inheritdoc */
  protected async getHeaderCellLabel(): Promise<string> {
    const provider = this.grid.dataProvider;
    let modelClass;
    let model;
    let models;
    let label;
    if (this.label === undefined) {
      if (
        provider instanceof ActiveDataProvider ||
        (provider instanceof ArrayDataProvider && provider.modelClass !== undefined)
      ) {
        modelClass = provider.modelClass;
        model = new modelClass({});
        label = model.getAttributeLabel(this.attribute);
      } else if (this.grid.filterModel !== undefined && this.grid.filterModel instanceof Model) {
        label = this.grid.filterModel.getAttributeLabel(this.filterAttribute);
      } else {
        models = await provider.getModels();
        model = models[0];
        if (model instanceof Model) {
          label = model.getAttributeLabel(this.attribute);
        } else {
          label = Inflector.humanize(this.attribute);
        }
      }
    } else label = this.label;
    return label;
  }
  /** @inheritdoc */
  protected renderFilterCellContent(): string {
    if (typeof this.filter === 'string') return this.filter;
    const model = this.grid.filterModel;
    if (this.filter !== false && model instanceof Model && this.filterAttribute !== undefined) {
      const options = { maxlength: true, ...this.filterInputOptions };
      return Html.activeTextInput(model, this.filterAttribute, options);
    }
    return super.renderFilterCellContent.call(this);
  }
  /**
   * Returns the data cell value.
   * @param model the data model
   * @param key the key associated with the data model
   * @param index the zero-based index of the data model among the models array returned by [[GridView.dataProvider]].
   * @return the data cell value
   */
  public getDataCellvalue(model: Model, key: string, index: number): string | null {
    if (this.value !== undefined) {
      if (typeof this.value === 'string') return this.value;
      return this.value(model, key, index, this);
    } else if (this.attribute !== undefined) return DataHelper.getValue(model, this.attribute);
    return null;
  }
  /** @inheritdoc */
  protected async renderDataCellContent(model: Model, key: string, index: number): Promise<string> {
    console.log('rdcc', model, key, index, this.attribute, this.content)
    if (this.content === undefined) return this.getDataCellvalue(model, key, index);
    return super.renderDataCellContent.call(this, model, key, index);
  }
}
